"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _defaults() {
  const data = _interopRequireDefault(require("lodash/defaults"));

  _defaults = function _defaults() {
    return data;
  };

  return data;
}

function _outputFileSync() {
  const data = _interopRequireDefault(require("output-file-sync"));

  _outputFileSync = function _outputFileSync() {
    return data;
  };

  return data;
}

function _slash() {
  const data = _interopRequireDefault(require("slash"));

  _slash = function _slash() {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function _fs() {
    return data;
  };

  return data;
}

var util = _interopRequireWildcard(require("./util"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let compiledFiles = 0;

function _default(commander, filenames, opts) {
  function write(src, base, callback) {
    let relative = _path().default.relative(base, src);

    if (!util.isCompilableExtension(relative, commander.extensions)) {
      return process.nextTick(callback);
    }

    relative = util.adjustRelative(relative, commander.keepFileExtension);
    const dest = getDest(commander, relative, base);
    util.compile(src, (0, _defaults().default)({
      sourceFileName: (0, _slash().default)(_path().default.relative(dest + "/..", src))
    }, opts), function (err, res) {
      if (err) return callback(err);
      if (!res) return callback();

      if (res.map && commander.sourceMaps && commander.sourceMaps !== "inline") {
        const mapLoc = dest + ".map";
        res.code = util.addSourceMappingUrl(res.code, mapLoc);
        res.map.file = _path().default.basename(relative);
        (0, _outputFileSync().default)(mapLoc, JSON.stringify(res.map));
      }

      (0, _outputFileSync().default)(dest, res.code);
      util.chmod(src, dest);
      compiledFiles += 1;
      util.log(src + " -> " + dest);
      return callback(null, true);
    });
  }

  function getDest(commander, filename, base) {
    if (commander.relative) return _path().default.join(base, commander.outDir, filename);
    return _path().default.join(commander.outDir, filename);
  }

  function outputDestFolder(outDir) {
    const outDirPath = _path().default.resolve(outDir);

    if (!_fs().default.existsSync(outDirPath)) {
      _fs().default.mkdirSync(outDirPath);
    }
  }

  function handleFile(src, base, callback) {
    write(src, base, function (err, res) {
      if (err) return callback(err);

      if (!res && commander.copyFiles) {
        const filename = _path().default.relative(base, src);

        const dest = getDest(commander, filename, base);
        (0, _outputFileSync().default)(dest, _fs().default.readFileSync(src));
        util.chmod(src, dest);
      }

      return callback();
    });
  }

  function sequentialHandleFile(files, dirname, index, callback) {
    if (files.length === 0) {
      outputDestFolder(commander.outDir);
      return;
    }

    if (typeof index === "function") {
      callback = index;
      index = 0;
    }

    const filename = files[index];

    const src = _path().default.join(dirname, filename);

    handleFile(src, dirname, function (err) {
      if (err) return callback(err);
      index++;

      if (index !== files.length) {
        sequentialHandleFile(files, dirname, index, callback);
      } else {
        callback();
      }
    });
  }

  function handle(filename, callback) {
    if (!_fs().default.existsSync(filename)) return;

    const stat = _fs().default.statSync(filename);

    if (stat.isDirectory(filename)) {
      const dirname = filename;

      if (commander.deleteDirOnStart) {
        util.deleteDir(commander.outDir);
      }

      const files = util.readdir(dirname, commander.includeDotfiles);
      sequentialHandleFile(files, dirname, callback);
    } else {
      write(filename, _path().default.dirname(filename), callback);
    }
  }

  function sequentialHandle(filenames, index = 0) {
    const filename = filenames[index];
    handle(filename, function (err) {
      if (err) throw new Error(err);
      index++;

      if (index !== filenames.length) {
        sequentialHandle(filenames, index);
      } else {
        util.log(`ðŸŽ‰  Successfully compiled ${compiledFiles} ${compiledFiles > 1 ? "files" : "file"} with Babel.`, true);
      }
    });
  }

  if (!commander.skipInitialBuild) {
    sequentialHandle(filenames);
  }

  if (commander.watch) {
    const chokidar = util.requireChokidar();
    filenames.forEach(function (filenameOrDir) {
      const watcher = chokidar.watch(filenameOrDir, {
        persistent: true,
        ignoreInitial: true,
        awaitWriteFinish: {
          stabilityThreshold: 50,
          pollInterval: 10
        }
      });
      ["add", "change"].forEach(function (type) {
        watcher.on(type, function (filename) {
          handleFile(filename, filename === filenameOrDir ? _path().default.dirname(filenameOrDir) : filenameOrDir, function (err) {
            if (err) console.error(err.stack);
          });
        });
      });
    });
  }
}
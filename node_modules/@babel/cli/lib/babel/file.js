"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _convertSourceMap() {
  const data = _interopRequireDefault(require("convert-source-map"));

  _convertSourceMap = function _convertSourceMap() {
    return data;
  };

  return data;
}

function _defaults() {
  const data = _interopRequireDefault(require("lodash/defaults"));

  _defaults = function _defaults() {
    return data;
  };

  return data;
}

function _sourceMap() {
  const data = _interopRequireDefault(require("source-map"));

  _sourceMap = function _sourceMap() {
    return data;
  };

  return data;
}

function _slash() {
  const data = _interopRequireDefault(require("slash"));

  _slash = function _slash() {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function _fs() {
    return data;
  };

  return data;
}

var util = _interopRequireWildcard(require("./util"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(commander, filenames, opts) {
  if (commander.sourceMaps === "inline") {
    opts.sourceMaps = true;
  }

  let results = [];

  const buildResult = function buildResult() {
    const map = new (_sourceMap().default.SourceMapGenerator)({
      file: commander.sourceMapTarget || _path().default.basename(commander.outFile || "") || "stdout",
      sourceRoot: opts.sourceRoot
    });
    let code = "";
    let offset = 0;
    results.forEach(function (result) {
      code += result.code + "\n";

      if (result.map) {
        const consumer = new (_sourceMap().default.SourceMapConsumer)(result.map);
        const sources = new Set();
        consumer.eachMapping(function (mapping) {
          if (mapping.source != null) sources.add(mapping.source);
          map.addMapping({
            generated: {
              line: mapping.generatedLine + offset,
              column: mapping.generatedColumn
            },
            source: mapping.source,
            original: mapping.source == null ? null : {
              line: mapping.originalLine,
              column: mapping.originalColumn
            }
          });
        });
        sources.forEach(source => {
          const content = consumer.sourceContentFor(source, true);

          if (content !== null) {
            map.setSourceContent(source, content);
          }
        });
        offset = code.split("\n").length - 1;
      }
    });

    if (commander.sourceMaps === "inline" || !commander.outFile && commander.sourceMaps) {
      code += "\n" + _convertSourceMap().default.fromObject(map).toComment();
    }

    return {
      map: map,
      code: code
    };
  };

  const output = function output() {
    const result = buildResult();

    if (commander.outFile) {
      if (commander.sourceMaps && commander.sourceMaps !== "inline") {
        const mapLoc = commander.outFile + ".map";
        result.code = util.addSourceMappingUrl(result.code, mapLoc);

        _fs().default.writeFileSync(mapLoc, JSON.stringify(result.map));
      }

      _fs().default.writeFileSync(commander.outFile, result.code);
    } else {
      process.stdout.write(result.code + "\n");
    }
  };

  const stdin = function stdin() {
    let code = "";
    process.stdin.setEncoding("utf8");
    process.stdin.on("readable", function () {
      const chunk = process.stdin.read();
      if (chunk !== null) code += chunk;
    });
    process.stdin.on("end", function () {
      util.transform(commander.filename, code, (0, _defaults().default)({
        sourceFileName: "stdin"
      }, opts), function (err, res) {
        if (err) throw err;
        results.push(res);
        output();
      });
    });
  };

  const walk = function walk() {
    const _filenames = [];
    results = [];
    filenames.forEach(function (filename) {
      if (!_fs().default.existsSync(filename)) return;

      const stat = _fs().default.statSync(filename);

      if (stat.isDirectory()) {
        const dirname = filename;
        util.readdirForCompilable(filename, commander.includeDotfiles).forEach(function (filename) {
          _filenames.push(_path().default.join(dirname, filename));
        });
      } else {
        _filenames.push(filename);
      }
    });
    let filesProcessed = 0;

    _filenames.forEach(function (filename, index) {
      let sourceFilename = filename;

      if (commander.outFile) {
        sourceFilename = _path().default.relative(_path().default.dirname(commander.outFile), sourceFilename);
      }

      sourceFilename = (0, _slash().default)(sourceFilename);
      util.compile(filename, (0, _defaults().default)({
        sourceFileName: sourceFilename
      }, opts), function (err, res) {
        if (err) throw err;
        filesProcessed++;
        if (res) results[index] = res;

        if (filesProcessed === _filenames.length) {
          output();
        }
      });
    });
  };

  const files = function files() {
    if (!commander.skipInitialBuild) {
      walk();
    }

    if (commander.watch) {
      const chokidar = util.requireChokidar();
      chokidar.watch(filenames, {
        persistent: true,
        ignoreInitial: true,
        awaitWriteFinish: {
          stabilityThreshold: 50,
          pollInterval: 10
        }
      }).on("all", function (type, filename) {
        if (!util.isCompilableExtension(filename, commander.extensions)) {
          return;
        }

        if (type === "add" || type === "change") {
          util.log(type + " " + filename);

          try {
            walk();
          } catch (err) {
            console.error(err.stack);
          }
        }
      });
    }
  };

  if (filenames.length) {
    files();
  } else {
    stdin();
  }
}